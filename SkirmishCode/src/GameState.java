import java.util.ArrayList;

/** GameState class: used for keeping track of states in the SkirmishCode game.
 * 
 * Player 1's HQ is in board location 0, 0 (upper left)
 * Player 2's HQ is in board location boardSize-1, boardSize-1 (bottom right)
 * 
 * On a player's turn, it can move one of its bots up, down, left, or right (when those positions exist and are not already occupied by one of its own bots)
 * or it can generate a new bot at its HQ assuming the space is free.
 * If a bot moves to a space occupied by the enemy, both the bot that moved and the bot already on the space are destroyed.
 * The game is won by getting a bot into the enemy's HQ.
 * 
 * @author Eric D. Manley
 *
 */
public class GameState 
{	
	/** internal representation of the game board, 0 means empty, 
	 *  1 means player 1 has a bot there, 2 means player 2 has a bot there */
	private int[][] board; 
	private int boardSize; /** side length of the square board */
	private int treeDepth; //!! remove this for students
	
	/**
	 * Constructor for creating a game state for a brand new game.
	 * 
	 * @param s - the size of the board (side length of the square) 
	 */
	public GameState(int s)
	{
		boardSize = s;
		board = new int[boardSize][boardSize];
		treeDepth = 0;
	}
	
	/**
	 * Copy constructor - used for creating the board from another one. This one
	 *  is used when generating successor states.
	 *  
	 *  @param other - the other GameState that this should be a copy of
	 */
	public GameState(GameState other)
	{
		boardSize = other.boardSize;
		board = new int[boardSize][boardSize]; //allocate space for a copy of the 2D array
		for(int r = 0; r < boardSize; r++) //actually copy the array
		{
			for(int c = 0; c < boardSize; c++)
			{
				board[r][c] = other.board[r][c];
			}
		}
		treeDepth = other.treeDepth + 1; //!! remove this for students
	}
	
	//!! remove
	public void resetDepth()
	{
		treeDepth = 0;
	}
	
	//!! remove
	public int getDepth()
	{
		return treeDepth;
	}
	
	//!! remove
	public boolean cutoffTest()
	{
		if(terminalTest())
		{
			return true;
		}
		else if(treeDepth > 4)
		{
			//System.out.println("Cutting off at \n"+this);
			//System.out.println("With eval "+eval());
			return true;
		}
		return false;
	}
	
	//!! remove
	public int eval()
	{
		int evalEst = 0;
		for(int r = 0; r < boardSize; r++)
		{
			for(int c = 0; c < boardSize; c++)
			{
				/*if(board[r][c] == 1)
				{
					evalEst++;
				}
				else if(board[r][c] == 2)
				{
					evalEst--;
				}*/
				if(board[r][c] == 1)
				{
					evalEst += 2*(r+c)-(boardSize-1-r)-(boardSize-1-c)+1;
				}
				else if(board[r][c] == 2)
				{
					evalEst -= 2*(r+c)-r-c+1;
				}
				
			}
		}
		
		if(board[0][0] == 2)
		{
			evalEst -= 2*boardSize*boardSize*boardSize+1;
		}
		
		if(board[boardSize-1][boardSize-1] == 1)
		{
			evalEst += 2*boardSize*boardSize*boardSize+1;
		}
		
		return evalEst;
	}
	
	
	/**
	 * For checking if this is an end-game state. This simply checks if the utility is non-zero.
	 * 
	 * @return true if the game is over, false otherwise
	 */
	public boolean terminalTest()
	{
		return (utility() != 0);
	}
	
	/**
	 * Gives the utility of this state. 
	 * 		0 means the game isn't over
	 * 		1 means player 1 wins (it has a bot in the bottom-right location - player 2's HQ)
	 * 		-1 means player 2 wins (it has a bot in the upper left location - player 1's HQ)
	 * 
	 * @return the utility of this game, -1, 0, or 1
	 */
	public int utility()
	{
		if(board[boardSize-1][boardSize-1] == 1)
		{
			return 1;
		}
		else if (board[0][0] == 2)
		{
			return -1;
		}
		else
		{
			return 0;
		}
	}
	
	/**
	 * Generates all of the successor states that are possible if it is Player 1's turn
	 * 
	 * @return an ArrayList of GameStates that can be generated by making all of Player 1's legal moves.
	 */
	public ArrayList<GameState> p1TurnGenerateSuccessors()
	{
		ArrayList<GameState> successors = new ArrayList<GameState>();
		
		//if I don't already have a bot on my HQ
		if(board[0][0] != 1)
		{
			GameState newState = new GameState(this);
			newState.board[0][0] = 1;
			successors.add(newState);
		}
		
		
		for(int r = 0; r < boardSize; r++)
		{
			for(int c = 0; c < boardSize; c++)
			{
				if(board[r][c] == 1) //if I've got a bot on this space
				{
					if(r > 0 && board[r-1][c] != 1) //bot can move down
					{
						GameState newState = new GameState(this);
						newState.p1move(r,c,r-1,c);
						successors.add(newState);

					}
					if(r < boardSize-1 && board[r+1][c] != 1) //bot can move up
					{
						GameState newState = new GameState(this);
						newState.p1move(r,c,r+1,c);
						successors.add(newState);
					}
					if(c > 0 && board[r][c-1] != 1) //bot can move left
					{
						GameState newState = new GameState(this);
						newState.p1move(r,c,r,c-1);
						successors.add(newState);
					}
					if(c < boardSize-1 && board[r][c+1] != 1) //bot can move right
					{
						GameState newState = new GameState(this);
						newState.p1move(r,c,r,c+1);
						successors.add(newState);
					}
				}
			}
		}
		
		return successors;
	}
	
	/**
	 * Generates all of the successor states that are possible if it is Player 2's turn
	 * 
	 * @return an ArrayList of GameStates that can be generated by making all of Player 2's legal moves.
	 */
	public ArrayList<GameState> p2TurnGenerateSuccessors()
	{
		ArrayList<GameState> successors = new ArrayList<GameState>();
		
		//if I don't already have a bot on my HQ
		if(board[boardSize-1][boardSize-1] != 2)
		{
			GameState newState = new GameState(this);
			newState.board[boardSize-1][boardSize-1] = 2;
			successors.add(newState);
		}
		
		
		for(int r = boardSize-1; r >= 0; r--)
		{
			for(int c = boardSize-1; c >= 0; c--)
			{
				if(board[r][c] == 2) //if I've got a bot on this space
				{
					if(r < boardSize-1 && board[r+1][c] != 2) //bot can move up
					{
						GameState newState = new GameState(this);
						newState.p2move(r,c,r+1,c);
						successors.add(newState);
					}
					if(r > 0 && board[r-1][c] != 2) //bot can move down
					{
						GameState newState = new GameState(this);
						newState.p2move(r,c,r-1,c);
						successors.add(newState);

					}
					if(c < boardSize-1 && board[r][c+1] != 2) //bot can move right
					{
						GameState newState = new GameState(this);
						newState.p2move(r,c,r,c+1);
						successors.add(newState);
					}
					if(c > 0 && board[r][c-1] != 2) //bot can move left
					{
						GameState newState = new GameState(this);
						newState.p2move(r,c,r,c-1);
						successors.add(newState);
					}

				}
			}
		}
		
		return successors;
	}
	
	/**
	 * Updates the board given a move by Player 1. This /does not/ check if the move is legal, so this is not a public method.
	 * 
	 * @param oldR - row moving from
	 * @param oldC - column moving from
	 * @param newR - row moving to
	 * @param newC - column moving to
	 */
	private void p1move(int oldR, int oldC, int newR, int newC)
	{
		if(board[newR][newC] == 2) //enemy is on this spot
		{
			board[newR][newC] = 0; //we're both dead
		}
		else
		{
			board[newR][newC] = 1; //we're in the new spot
		}
		board[oldR][oldC] = 0; //vacating old spot
	}
	
	/**
	 * Updates the board given a move by Player 2. This /does not/ check if the move is legal, so this is not a public method.
	 * 
	 * @param oldR - row moving from
	 * @param oldC - column moving from
	 * @param newR - row moving to
	 * @param newC - column moving to
	 */
	private void p2move(int oldR, int oldC, int newR, int newC)
	{
		if(board[newR][newC] == 1) //enemy is on this spot
		{
			board[newR][newC] = 0; //we're both dead
		}
		else
		{
			board[newR][newC] = 2; //we're in the new spot
		}
		board[oldR][oldC] = 0; //vacating old spot
	}
	
	
	/**
	 * Creates a string representing the game board so that it can be printed.
	 * 
	 * @return a string representing the game board
	 */
	public String toString()
	{
		String rVal = "";
		for(int r = 0; r < boardSize; r++)
		{
			for(int c = 0; c < boardSize; c++)
			{
				rVal += board[r][c] + " ";
			}
			rVal += "\n";
		}
		return rVal;
	}
	
}
